// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import { PRBTest } from "@prb/test/src/PRBTest.sol";
import "../src/AlignFoundersNFT.sol";
import "../src/AlignNFTStaking.sol";
import "forge-std/src/console2.sol";

contract AlignStationTest is PRBTest {
  AlignFoundersNFT alignFoundersNFT;
  AlignNFTStaking alignNFTStaking;
  address owner = address(1);
  address user = address(2);

  function setUp() public {
    alignFoundersNFT = new AlignFoundersNFT("AlignFoundersNFT", "AFN", "baseURI/", 0x0);
    alignNFTStaking = new AlignNFTStaking(address(alignFoundersNFT));
    alignFoundersNFT.setStaker(address(alignNFTStaking));
    alignFoundersNFT.transferOwnership(owner);
    vm.startPrank(owner);
    alignFoundersNFT.enablePublicMint();
    vm.stopPrank();

    vm.deal(user, 100 ether);
    vm.deal(owner, 100 ether);
  }

  function testACase_MintAndCheckStaked() public {
    // Assuming you've run the script and have the Merkle root and proof
    bytes32 merkleRoot = 0x32ce85405983c392122c7c4869690b8081fc9ecec74276206caea196c6e545cb; // Merkle root generated by your script
    bytes32[] memory merkleProof = new bytes32[](1);
    merkleProof[0] = 0x5b70e80538acdabd6137353b0f9d8d149f4dba91e8be2e7946e409bfdbe685b9; // Merkle proof for the user address generated by your script

    // Set the contract's merkleRoot to the generated merkleRoot
    vm.startPrank(owner);
    alignFoundersNFT.setMerkleRoot(merkleRoot);

    // Set the mint start time to allow minting (e.g., current block timestamp minus 100 seconds)
    uint256 mintStartTime = block.timestamp - 100;
    alignFoundersNFT.setMintStartTime(mintStartTime);
    vm.stopPrank();

    // Whitelist mint an NFT for the user and check it's staked
    vm.startPrank(user);
    alignFoundersNFT.whitelistMint{ value: 0.15 ether }(merkleProof);
    vm.stopPrank();

    uint256 stakedAmount = alignNFTStaking.getStakedAmount(user);
    uint256[] memory stakedIds = alignNFTStaking.getStakedIds(user);

    assertEq(stakedAmount, 1, "User should have 1 staked token");
    assertEq(stakedIds.length, 1, "User should have an array of staked token IDs with length 1");

    // Attempt to unstake (should fail if unstaking is not allowed yet)
    vm.expectRevert("MintingInProgress"); // Adjust based on the actual revert message
    vm.prank(user);
    alignNFTStaking.unstake(stakedIds[0]);
  }

  function testBCase_Mint10000AndUnstake() public {
    // Mint 10,000 NFTs by user
    vm.startPrank(user);
    for (uint i = 0; i < 10000; i++) {
      alignFoundersNFT.publicMint{ value: 0.15 ether }();
    }
    vm.stopPrank();

    uint256 stakedAmountBeforeUnstake = alignNFTStaking.getStakedAmount(user);
    assertEq(stakedAmountBeforeUnstake, 10000, "User should have 10,000 staked tokens before unstaking");

    // Unstake the first NFT
    uint256[] memory stakedIds = alignNFTStaking.getStakedIds(user);
    vm.prank(user);
    alignNFTStaking.unstake(stakedIds[0]);

    uint256 stakedAmountAfterUnstake = alignNFTStaking.getStakedAmount(user);
    assertEq(stakedAmountAfterUnstake, 9999, "User should have 9,999 staked tokens after unstaking");
  }

  // Helper function to handle ether transfers for testing
  receive() external payable {}
}
